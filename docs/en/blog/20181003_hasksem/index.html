<!DOCTYPE html>
<html><head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    
    <link rel="shortcut icon" href="https://www.hayashi-lin.net/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.min.css">

    <title>An implementation of a fragment of Heim &amp; Kratzer (1998)&#39;s NL semantics</title>
</head>
<body><header id="banner">
    <h2><a href="https://www.hayashi-lin.net/">Noritsugu Hayashi</a></h2>
    <nav>
        <ul>
            
            <li>
                <a href="/en/cv/" title="CV">CV</a>
            </li>
            
            <li>
                <a href="/en/blog/" title="Blog">Blog</a>
            </li>
            
            
        </ul>
    </nav>
    <nav>
        <ul>
            
            
                <li>
                    <a href="/ja/blog/20181003_hasksem/">
                        日本語
                    </a>
                </li>
            
        </ul>
    </nav>
</header>
<main id="content">
<article>
    <header id="post-header">
        <h1>An implementation of a fragment of Heim &amp; Kratzer (1998)&#39;s NL semantics</h1><time>October 3, 2018</time></header><p>I made a little attempt to give an implementation of some features of 
Heim &amp; Kratzer (1998) using Haskell,
which covers 
the semantic calculation of one-place predicates applied to entities and
generalized quantifiers applied to (pairs of) one-place predicates.</p>
<h2 id="usage">Usage</h2>
<p>Launch GHCi, load the source code below, and make your queries.</p>
<p>Examples:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-Haskell" data-lang="Haskell"><span style="color:#66d9ef">Prelude</span><span style="color:#f92672">&gt;</span> <span style="color:#66d9ef">:</span>l <span style="color:#66d9ef">GQ</span><span style="color:#f92672">.</span>hs
<span style="color:#66d9ef">Prelude</span><span style="color:#f92672">&gt;</span> sleep <span style="color:#66d9ef">Mary</span>
<span style="color:#66d9ef">False</span>
<span style="color:#66d9ef">Prelude</span><span style="color:#f92672">&gt;</span> a student sleep
<span style="color:#66d9ef">True</span>
</code></pre></div><h2 id="source-code">Source code</h2>
<p>Shown below.</p>
<ul>
<li>The object language is a fragment of clumsy English 
(in cluttered word orders),
sentences of which are actually nothing but Haskell expressions.
<ul>
<li>The (syntactic) categories of those expressions 
are not overtly represented 
since they are totally determined by the (semantic) types 
of those interpretations.
The &ldquo;types&rdquo; such as <code>Entity</code>，<code>Truth</code> belong to semantics.</li>
</ul>
</li>
<li>The meta-language is, of course, Haskell.
<ul>
<li>Based on <em>the functional talk</em>.</li>
<li>A certain trick is needed to enumerate the type constructors of
<code>Entity</code>. The <code>Data.Data</code> module enables it.</li>
</ul>
</li>
<li>The interpreter of the meta-language is GHCi.</li>
</ul>
<script type="application/javascript" src="https://gist.github.com/aslemen/3d179c13b24ab6e827101de4194c5755.js"></script>

<hr>
<ul>
<li>Oct 3 2018 modified</li>
<li>Oct 3 2018 translated to English</li>
</ul>
</article>

        </main><footer id="footer">
    Copyright © 2016–2020 Noritsugu Hayashi
</footer>
</body>
</html>
